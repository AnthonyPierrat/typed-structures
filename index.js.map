{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/exceptions/exception.ts","webpack:///./src/collections/buffer/buffer.ts","webpack:///./src/collections/linked-list/utils/node/node.ts","webpack:///./src/exceptions/illegal-argument-exception.ts","webpack:///./src/exceptions/null-reference-exception.ts","webpack:///./src/collections/map/utils/map-entry/map-entry.ts","webpack:///./src/collections/linked-list/doubly-linked-list/doubly-linked-list.ts","webpack:///./src/collections/linked-list/singly-linked-list/singly-linked-list.ts","webpack:///./src/exceptions/invalid-mark-exception.ts","webpack:///./src/collections/buffer/generic-buffer/generic-buffer.ts","webpack:///./src/collections/buffer/generic-ring-buffer/generic-ring-buffer.ts","webpack:///./src/util/flatten.ts","webpack:///./src/util/hash.ts","webpack:///./src/collections/set/set.ts","webpack:///./src/collections/map/map.ts","webpack:///./src/collections/queue/queue.ts","webpack:///./src/collections/stack/stack.ts","webpack:///./src/exceptions/class-cast-exception.ts","webpack:///./src/exceptions/index-out-of-bounds-exception.ts","webpack:///./src/exceptions/read-only-buffer-exception.ts","webpack:///./src/exceptions/unsupported-operation-exception.ts","webpack:///./src/functions/bi-function/bi-function.ts","webpack:///./src/functions/function/function.ts","webpack:///./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Exception","[object Object]","message","this","_message","illegal_argument_exception_1","invalid_mark_exception_1","Buffer","capacity","limit","position","mark","_cap","_limit","_pos","_mark","IllegalArgumentException","remaining","newLimit","newPosition","undefined","InvalidMarkException","Node","data","_data","_next","_previous","next","node","previous","exception_1","super","toString","NullReferenceException","hash_1","flatten_1","MapEntry","_value","_key","getKey","getValue","hashCode","flattenObject","hash","old","node_1","DoublyLinkedList","_size","length","item","empty","_head","_tail","result","current","callback","index","forEach","push","filter","element","SinglyLinkedList","hasNext","buffer_1","GenericBuffer","readonly","_buf","Array","_readonly","isReadOnly","GenericRingBuffer","readPosition","_readPosition","obj","prefix","JSON","stringify","keys","reduce","acc","k","pre","assign","str","split","currentVal","charCodeAt","null_reference_exception_1","Set","_elements","e","contains","add","every","size","toArray","equals","accumulator","remove","set","addAll","set_1","map_entry_1","Map","_entries","remappingFunction","oldValue","newValue","apply","put","mappingFunction","v","find","entry","entrySet","map","mapEntry","defaultValue","previousValue","containsKey","setValue","f","doubly_linked_list_1","Queue","_items","shift","peek","back","singly_linked_list_1","Stack","unshift","ClassCastException","IndexOutOfBoundsException","ReadOnlyBufferException","UnsupportedOperationException","BiFunction","_function","after","u","getNativeFunction","Function","before","FunctionImport","BiFunctionImport","UnsupportedOperationExceptionImport","ReadOnlyBufferExceptionImport","NullReferenceExceptionImport","InvalidMarkExceptionImport","IndexOutOfBoundsExceptionImport","IllegalArgumentExceptionImport","ExceptionImport","ClassCastExceptionImport","StackImport","QueueImport","MapImport","MapEntryImport","NodeImport","SinglyLinkedListImport","DoublyLinkedListImport","BufferImport","GenericRingBufferImport","GenericBufferImport"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 23);\n","export class Exception {\n\n    private _message: string;\n\n    constructor(message: string) {\n        this._message = message;\n    }\n\n    toString(): string {\n        return `Exception: ${this._message}\\n`;\n    }\n}","import { IBuffer } from './buffer-interface';\nimport { IllegalArgumentException } from '../../exceptions/illegal-argument-exception';\nimport { InvalidMarkException } from '../../exceptions/invalid-mark-exception';\n\nexport abstract class Buffer implements IBuffer {\n\n    private readonly _cap: number = 0;\n    private _limit: number = 0;\n    private _pos: number = 0;\n    private _mark: number = -1;\n\n    protected constructor(capacity: number, limit: number, position: number, mark: number) {\n        if (capacity < 0)\n            throw new IllegalArgumentException ('Negative capacity');\n\n        this._cap = capacity;\n        this.limit(limit);\n        this.position(position);\n\n        if (mark >= 0) {\n            if (mark > this._pos)\n                throw new IllegalArgumentException ('Mark is greater than current position');\n            this._mark = mark;\n        }\n    }\n\n    public capacity(): number {\n        return this._cap;\n    }\n\n    public clear(): IBuffer {\n        this._limit = this._cap;\n        this._pos = 0;\n        this._mark = -1;\n        return this;\n    }\n\n    public flip(): IBuffer {\n        this._limit = this._pos;\n        this._pos = 0;\n        this._mark = -1;\n        return this;\n    }\n\n    public hasRemaining(): boolean {\n        return this.remaining() > 0;\n    }\n\n    public abstract isReadOnly(): boolean;\n\n    public limit(): number;\n    public limit(newLimit: number): IBuffer;\n    public limit(newLimit?: number): any {\n\n        if (!newLimit)\n            return this._limit;\n\n        if ((newLimit < 0) || (newLimit > this._cap))\n            throw new IllegalArgumentException ('New limit out of bound');\n\n        if (newLimit < this._mark)\n            this._mark = -1;\n\n        if (this._pos > newLimit)\n            this._pos = newLimit;\n\n        this._limit = newLimit;\n        return this;\n    }\n\n    public mark (): IBuffer {\n        this._mark = this._pos;\n        return this;\n    }\n\n    public position(): number;\n    public position(newPosition: number): IBuffer;\n    public position(newPosition?: number): any {\n\n        if (newPosition === undefined)\n            return this._pos;\n\n        if ((newPosition < 0) || (newPosition > this._limit))\n            throw new IllegalArgumentException ('New position out of bound');\n\n        if (newPosition <= this._mark)\n            this._mark = -1;\n\n        this._pos = newPosition;\n        return this;\n    }\n\n    public remaining(): number {\n        return this._limit - this._pos;\n    }\n\n    public reset(): IBuffer {\n        if (this._mark === -1)\n            throw new InvalidMarkException();\n\n        this._pos = this._mark;\n        return this;\n    }\n\n    public rewind(): IBuffer {\n        this._pos = 0;\n        this._mark = -1;\n        return this;\n    }\n}","import {INode} from './node-interface';\n\nexport class Node<T> implements INode {\n\n    private _data: T;\n    private _next?: Node<T>;\n    private _previous?: Node<T>;\n\n    constructor(data: T) {\n        this._data = data;\n        this._next = undefined;\n        this._previous = undefined;\n    }\n\n    get data(): T {\n        return this._data;\n    }\n\n    get next(): Node<T> | undefined {\n        return this._next;\n    }\n\n    set data(data: T) {\n        this._data = data;\n    }\n\n    set next(node: Node<T> | undefined) {\n        this._next = node;\n    }\n\n    get previous(): Node<T> | undefined {\n        return this._previous;\n    }\n\n    set previous(previous: Node<T> | undefined) {\n        this._previous = previous;\n    }\n\n    public hasNext(): boolean {\n        return this._next !== undefined && this._next !== null;\n    }\n\n    public hasPrevious(): boolean {\n        return this._previous !== undefined && this._previous !== null;\n    }\n}","import { Exception } from './exception';\n\nexport class IllegalArgumentException extends Exception {\n\n    constructor(message: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `IllegalArgument${super.toString()}`;\n    }\n}","import { Exception } from './exception';\n\nexport class NullReferenceException extends Exception {\n\n    constructor(message: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `NullReference${super.toString()}`;\n    }\n}","import { hash } from '../../../../util/hash';\nimport { flattenObject } from '../../../../util/flatten';\nimport { IMapEntry } from './map-entry-interface';\n\nexport class MapEntry<K, V> implements IMapEntry<K, V> {\n\n    private _key: K;\n    private _value: V;\n\n    constructor(key: K, value: V) {\n        this._value = value;\n        this._key = key;\n    }\n\n    equals(o: any): boolean {\n        return (this.getKey() === null ? o.getKey() === null : this.getKey() === o.getKey()) &&\n            (this.getValue() === null ? o.getValue() === null : this.getValue() === o.getValue());\n    }\n\n    getKey(): K {\n        return this._key;\n    }\n\n    getValue(): V {\n        return this._value;\n    }\n\n    hashCode(): number {\n        let key: string = typeof this._key === 'object' ? typeof (<any>this._key).hashCode === 'function' ? (<any>this._key).hashCode() : flattenObject(this._key) : this._key;\n        let value: string = typeof this._value === 'object' ? typeof (<any>this._value).hashCode === 'function' ? (<any>this._value).hashCode() : flattenObject(this._value) : this._value;\n\n        return hash( <string>key + <string>value);\n    }\n\n    setValue(value: V): V {\n        let old: V = this.getValue();\n        this._value = value;\n        return old;\n    }\n\n}","import { Node } from '../utils/node/node';\nimport { ILinkedList } from '../linked-list-interface';\n\nexport class DoublyLinkedList<T> implements ILinkedList<T> {\n\n    private _head?: Node<T>;\n    private _tail?: Node<T>;\n    private _size: number;\n\n    constructor() {\n        this._size = 0;\n    }\n\n    public length(): number {\n        return this._size;\n    }\n\n    public empty(): boolean {\n        return this.length() === 0;\n    }\n\n    public unshift(item: T) {\n        if (item === undefined) {\n            return 0;\n        }\n\n        if (this.empty()) {\n            this._head = this.create(item);\n            this._tail = this._head;\n\n        } else {\n            const node = this.create(item);\n            node.next = this._head;\n            this._head.previous = node;\n            this._head = node;\n        }\n\n        ++this._size;\n\n        return this._size;\n    }\n\n    public shift(): T {\n        if (this.empty()) {\n            return undefined;\n        }\n        if (this.length() === 1) {\n            const result = this._head;\n            this._head = undefined;\n            --this._size;\n            return result.data;\n        } else {\n            let result = this._head;\n            this._head = this._head.next;\n            this._head.previous = undefined;\n            --this._size;\n            return result.data;\n        }\n    }\n\n    public push(item: T): void {\n        if (this.empty()) {\n            this._head = this._tail = this.create(item);\n\n        } else {\n            let current = this.create(item);\n            this._tail.next = current;\n            current.previous = this._tail;\n            this._tail = current;\n        }\n\n        ++this._size;\n    }\n\n    public pop(): T {\n\n        if (this.empty()) {\n            return undefined;\n        }\n\n        if (this.length() === 1) {\n            let current = this._head;\n            this._head = this._tail = undefined;\n            --this._size;\n            return current.data;\n\n        } else {\n            let current = this._tail;\n            this._tail = this._tail.previous;\n            this._tail.next = undefined;\n            --this._size;\n            return current.data;\n        }\n\n    }\n\n    public remove(item: T): T {\n        if (this.empty())\n            return undefined;\n\n        else if (this.length() === 1) {\n            let current = this._head;\n            this._head = this._tail = undefined;\n            --this._size;\n            return current.data;\n        }\n        else {\n            let current = this._head;\n            if (this._head.data === item) {\n                this._head = this._head.next;\n                return current.data;\n            }\n\n            let previous: Node<T>;\n            while (current.next && current.data !== item) {\n                previous = current;\n                current = current.next;\n            }\n\n            previous.next = current.next;\n\n            --this._size;\n            return current.data;\n\n        }\n    }\n\n    public forEach(callback: Function) {\n        let current = this._head;\n        let index = 0;\n        while (current) {\n            callback.call(current, current, index++, this);\n            current = current.next;\n        }\n    }\n\n    public filter(callback: Function): DoublyLinkedList<T> {\n        let result = new DoublyLinkedList<T>();\n        this.forEach((item: Node<T>, index: number) => {\n            if (callback.call(item.data, item.data, index, this)) {\n                result.push(item.data);\n            }\n        });\n        return result;\n    }\n\n    public includes(item: T): boolean {\n        return this.filter((element: T) => element === item).length() > 0;\n    }\n\n    public indexOf(item: T): number {\n        let index = 0;\n        let current = this._head;\n\n        while (current) {\n            if (current.data === item) {\n                return index;\n            }\n            current = current.next;\n            ++index;\n        }\n\n        return -1;\n\n    }\n\n    private create(item: T): Node<T> {\n        return new Node<T>(item);\n    }\n\n    public peek(): T {\n        return this._head.data;\n    }\n\n    public back(): T {\n        return this._tail.data;\n    }\n\n    public clear(): void {\n        this._head = this._tail = undefined;\n        this._size = 0;\n    }\n\n    public contains(item: T): boolean {\n        if (!this._head)\n            return false;\n\n        let current: Node<T> = this._head;\n\n        while (current) {\n            if (current.data === item)\n                return true;\n            current = current.next;\n        }\n        return false;\n    }\n\n    public find(item: T): Node<T> {\n        let current = this._head;\n        while (current) {\n            if (current.data === item)\n                return current;\n            current = current.next;\n        }\n        return undefined;\n    }\n}","import {Node} from '../utils/node/node';\nimport {ILinkedList} from '../linked-list-interface';\n\nexport class SinglyLinkedList<T> implements ILinkedList<T> {\n\n    private _head?: Node<T>;\n    private _size: number;\n\n    constructor() {\n        this._size = 0;\n    }\n\n    clear(): void {\n        this._head = undefined;\n        this._size = 0;\n    }\n\n    contains(item: T): boolean {\n        if (!this._head)\n            return false;\n\n        let current: Node<T> = this._head;\n\n        while (current) {\n            if (current.data === item)\n                return true;\n            current = current.next;\n        }\n        return false;\n    }\n\n    empty(): boolean {\n        return this._size === 0;\n    }\n\n    filter(callback: Function): SinglyLinkedList<T> {\n        let result = new SinglyLinkedList<T>();\n        this.forEach((item: Node<T>, index: number) => {\n            if (callback.call(item.data, item.data, index, this)) {\n                result.push(item.data);\n            }\n        });\n        return result;\n    }\n\n    find(item: T): Node<T> {\n        let current = this._head;\n        while (current) {\n            if (current.data === item)\n                return current;\n            current = current.next;\n        }\n        return undefined;\n    }\n\n\n    forEach(callback: Function): void {\n        let current = this._head;\n        let index = 0;\n        while (current) {\n            callback.call(current, current, index++, this);\n            current = current.next;\n        }\n    }\n\n    includes(item: T): boolean {\n        return this.filter((element: T) => element === item).length() > 0;\n    }\n\n    indexOf(item: T): number {\n        let index = 0;\n        let current = this._head;\n\n        while (current) {\n            if (current.data === item) {\n                return index;\n            }\n            current = current.next;\n            ++index;\n        }\n\n        return -1;\n    }\n\n    length(): number {\n        return this._size;\n    }\n\n    peek(): T {\n        return this._head.data;\n    }\n\n    back(): T {\n        let current = this._head;\n        while (current.hasNext()) {\n            current = current.next;\n        }\n        return current.data;\n    }\n\n    pop(): T {\n        if (this.empty()) {\n            return undefined;\n        }\n\n        let current = this._head;\n\n        if (this.length() === 1) {\n            this._head = undefined;\n\n        } else {\n            let previous: Node<T>;\n\n            while (current.hasNext()) {\n                previous = current;\n                current = current.next;\n            }\n\n            previous.next = undefined;\n        }\n\n        --this._size;\n\n        return current.data;\n    }\n\n    push(item: T): void {\n        if (this.empty()) {\n            this._head = this.create(item);\n\n        } else {\n            let current = this._head;\n\n            while (current.hasNext()) {\n                current = current.next;\n            }\n            current.next = this.create(item);\n        }\n\n        ++this._size;\n    }\n\n    remove(item: T): T {\n        if (this.empty())\n            return undefined;\n\n        else if (this.length() === 1) {\n            let current = this._head;\n            this._head = undefined;\n            --this._size;\n            return current.data;\n        }\n        else {\n            let current = this._head;\n            if (this._head.data === item) {\n                this._head = this._head.next;\n                return current.data;\n            }\n\n            let previous: Node<T>;\n            while (current.hasNext() && current.data !== item) {\n                previous = current;\n                current = current.next;\n            }\n\n            previous.next = current.next;\n\n            --this._size;\n            return current.data;\n\n        }\n    }\n\n    shift(): T {\n        if (this.empty()) {\n            return undefined;\n        } else {\n            let result = this._head;\n            this._head = this._head.next;\n            --this._size;\n            return result.data;\n        }\n    }\n\n    unshift(item: T): number {\n        if (item === undefined) {\n            return 0;\n        }\n\n        if (this._head === undefined) {\n            this._head = this.create(item);\n\n        } else {\n            const node = this.create(item);\n            node.next = this._head;\n            this._head = node;\n        }\n\n        ++this._size;\n\n        return this._size;\n    }\n\n    private create(item: T): Node<T> {\n        return new Node<T>(item);\n    }\n}","import { Exception } from './exception';\n\nexport class InvalidMarkException extends Exception {\n\n    constructor(message?: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `InvalidMark${super.toString()}`;\n    }\n}","import { Buffer } from '../buffer';\nimport { IBuffer } from '../buffer-interface';\n\nexport class GenericBuffer<T> extends Buffer {\n\n    private readonly _buf: T[];\n    private readonly _readonly: boolean;\n\n    constructor(capacity: number, limit: number, position: number, mark: number, readonly: boolean = false) {\n        super(capacity, limit, position, mark);\n        this._buf = new Array<T>(capacity);\n        this._readonly = readonly;\n    }\n\n    public get(): T {\n        this.position(this.position() + 1);\n        return this._buf[this.position() - 1];\n    }\n\n    public put(element: T): IBuffer {\n        if (!this.isReadOnly()) {\n            this._buf[this.position()] = element;\n            this.position(this.position() + 1);\n        }\n        return this;\n    }\n\n    isReadOnly(): boolean {\n        return this._readonly;\n    }\n}","import { Buffer } from '../buffer';\nimport { IBuffer } from '../buffer-interface';\nimport {IllegalArgumentException} from '../../../exceptions/illegal-argument-exception';\n\nexport class GenericRingBuffer<T> extends Buffer {\n\n    private readonly _buf: T[];\n    private readonly _readonly: boolean;\n    private _readPosition: number;\n\n    constructor(capacity: number, limit: number, position: number, readPosition: number, mark: number, readonly: boolean = false) {\n        super(capacity, limit, position, mark);\n        this._readPosition = readPosition;\n        this._buf = new Array<T>(capacity);\n        this._readonly = readonly;\n    }\n\n    public get(): T {\n        let position: number = (this.readPosition() + 1) % this.capacity();\n        this.readPosition(position);\n        return this._buf[position - 1];\n    }\n\n    public put(element: T): IBuffer {\n        this._buf[this.position()] = element;\n        this.position((this.position() + 1) % this.capacity());\n        return this;\n    }\n\n    isReadOnly(): boolean {\n        return this._readonly;\n    }\n\n    public readPosition(): number;\n    public readPosition(newPosition: number): IBuffer;\n    public readPosition(newPosition?: number): any {\n\n        if (newPosition === undefined)\n            return this._readPosition;\n\n        if ((newPosition < 0) || (newPosition > this.limit()))\n            throw new IllegalArgumentException ('New read position out of bound');\n\n        this._readPosition = newPosition;\n        return this;\n    }\n}","export function flattenObject(obj: any, prefix = '') {\n    return JSON.stringify(Object.keys(obj).reduce((acc: any, k: string) => {\n        const pre: string = prefix.length ? prefix + '.' : '';\n        if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k));\n        else acc[pre + k] = obj[k];\n        return acc;\n    }, {}));\n}","export function hash(str: string) {\n    let arr: string[] = (str + '').split('');\n    return arr.reduce(\n        (hashCode, currentVal) =>\n            (hashCode = currentVal.charCodeAt(0) + (hashCode << 6) + (hashCode << 16) - hashCode),\n        0\n    );\n}","import {ISetInterface} from './set-interface';\nimport {NullReferenceException} from '../../exceptions/null-reference-exception';\nimport {IMapEntry} from '../map/utils/map-entry/map-entry-interface';\n\nexport class Set<E> implements ISetInterface<E> {\n\n    private _elements: E[];\n\n    constructor() {\n        this._elements = [];\n    }\n\n    add(e: E): boolean {\n\n        if (e === null || e === undefined)\n            throw new NullReferenceException('The element cannot be null nor undefined');\n\n        if (this.contains(e))\n            return false;\n        else {\n            this._elements.push(e);\n            return true;\n        }\n    }\n\n    addAll(c: E[]): boolean {\n        let length: number = this._elements.length;\n        c.forEach((element: E) => this.add(element));\n        return this._elements.length !== length;\n    }\n\n    clear(): void {\n        this._elements.length = 0;\n    }\n\n    contains(o: any): boolean {\n        if (o === null || o === undefined)\n            throw new NullReferenceException('The element cannot be null nor undefined');\n\n        return this._elements\n            .filter((e: E) => e === o).length > 0;\n    }\n\n    containsAll(c: any[]): boolean {\n\n        if (c === null || c === undefined)\n            throw new NullReferenceException('The collection cannot be null nor undefined');\n\n        return c.every((e: E) => this.contains(e));\n    }\n\n    equals(o: ISetInterface<E>): boolean {\n        return this.size() === o.size() && o.toArray().every((e: E, index: number) => {\n            if ((<any>e).equals)\n                return (<any>e).equals(this._elements[index]);\n            else\n                return e === this._elements[index];\n        });\n    }\n\n    hashCode(): number {\n        let hash: number = 1;\n        return this.toArray().reduce((accumulator: number, e: any) => {\n            if (e.hashCode)\n                hash = hash * 31 + e.hashCode();\n            else\n                hash = hash * 17 + +e;\n            return hash;\n        }, 0);\n    }\n\n    isEmpty(): boolean {\n        return this._elements.length === 0;\n    }\n\n    remove(o: any): boolean {\n\n        if (o === null || o === undefined)\n            throw new NullReferenceException('The element cannot be null nor undefined');\n\n        if (!this.contains(o))\n            return false;\n        else {\n            this._elements = this._elements.filter((e: E) => e !== o);\n            return true;\n        }\n    }\n\n    removeAll(c: any[]): boolean {\n        if (c === null || c === undefined)\n            throw new NullReferenceException('The collection cannot be null nor undefined');\n\n        let length: number = this._elements.length;\n        c.forEach((e: E) => this.remove(e));\n        return this._elements.length !== length;\n    }\n\n    retainAll(c: any[]): boolean {\n        if (c === null || c === undefined)\n            throw new NullReferenceException('The collection cannot be null nor undefined');\n\n        let length: number = this._elements.length;\n\n        let set: Set<E> = new Set<E>();\n        set.addAll(c);\n\n        this._elements = this._elements.filter((e: E) => set.contains(e));\n        return this._elements.length !== length;\n    }\n\n    size(): number {\n        return this._elements.length;\n    }\n\n    toArray(): E[] {\n        return this._elements;\n    }\n}","import {IMap} from './map-interface';\nimport {IBiFunction} from '../../functions/bi-function/bi-function-interface';\nimport {IFunction} from '../../functions/function/function-interface';\nimport {ISetInterface} from '../set/set-interface';\nimport {IMapEntry} from './utils/map-entry/map-entry-interface';\nimport {NullReferenceException} from '../../exceptions/null-reference-exception';\nimport {Set} from '../set/set';\nimport {MapEntry} from './utils/map-entry/map-entry';\n\nexport class Map<K, V> implements IMap<K, V> {\n\n    private _entries: IMapEntry<K, V>[];\n\n    constructor() {\n        this._entries = [];\n    }\n\n    clear(): void {\n        this._entries.length = 0;\n    }\n\n    compute(key: K, remappingFunction: IBiFunction<K, V, V>): V {\n\n        let oldValue: V = this.get(key);\n        let newValue: V = remappingFunction.apply(key, oldValue);\n        if (oldValue !== null) {\n            if (newValue !== null) {\n                return this.put(key, newValue);\n            } else {\n                return this.remove(key);\n            }\n        } else {\n            if (newValue !== null) {\n                return this.put(key, newValue);\n            } else {\n                return null;\n            }\n        }\n    }\n\n    computeIfAbsent(key: K, mappingFunction: IFunction<K, V>): V {\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        if (this.get(key) === null) {\n            let newValue: V = mappingFunction.apply(key);\n            if (newValue !== null)\n                return this.put(key, newValue);\n        }\n    }\n\n    computeIfPresent(key: K, v: IBiFunction<K, V, V>): V {\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        if (this.get(key) !== null) {\n            let oldValue: V = this.get(key);\n            let newValue: V = v.apply(key, oldValue);\n            if (newValue !== null)\n                return this.put(key, newValue);\n            else\n                return this.remove(key);\n        }\n    }\n\n    containsKey(key: any): boolean {\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        return this._entries.find((entry: IMapEntry<K, V>) => {\n            return entry.getKey() === key;\n        }) !== undefined;\n    }\n\n    containsValue(value: any): boolean {\n\n        if (value === null || value === undefined)\n            throw new NullReferenceException('The value cannot be null nor undefined');\n\n        return this._entries.find((entry: IMapEntry<K, V>) => {\n            return entry.getValue() === value;\n        }) !== undefined;\n    }\n\n    entrySet(): ISetInterface<IMapEntry<K, V>> {\n        let set: ISetInterface<IMapEntry<K, V>> = new Set<MapEntry<K, V>>();\n        set.addAll(this._entries);\n        return set;\n    }\n\n    equals(m: IMap<K, V>): boolean {\n        return this.entrySet().equals(m.entrySet());\n    }\n\n    forEach(callback: IFunction<IMapEntry<K, V>, IMapEntry<K, V>>): void {\n        this._entries = this._entries.map(mapEntry => callback.apply(mapEntry));\n    }\n\n    get(key: K): V {\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        try {\n            return this._entries\n                .find((mapEntry: IMapEntry<K, V>) => mapEntry.getKey() === key)\n                .getValue();\n        } catch (e) {\n            return null;\n        }\n    }\n\n    getOrDefault(key: K, defaultValue: V): V {\n        let get = this.get(key);\n        if (get) {\n            return get;\n        } else {\n            return defaultValue;\n        }\n    }\n\n    hashCode(): number {\n        return this.entrySet().toArray().reduce((accumulator: number, mapEntry: IMapEntry<K, V>) => {\n            return accumulator + mapEntry.hashCode();\n        }, 0);\n    }\n\n    isEmpty(): boolean {\n        return this._entries.length === 0;\n    }\n\n    keySet(): ISetInterface<K> {\n        return this._entries.reduce((set: ISetInterface<K>, mapEntry: IMapEntry<K, V>) => {\n            set.add(mapEntry.getKey());\n            return set;\n        }, new Set<K>());\n    }\n\n    merge(key: K, value: V, remappingFunction: IBiFunction<V, V, V>): V {\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        let oldValue: V = this.get(key);\n        let newValue: V = (oldValue === null) ? value : remappingFunction.apply(oldValue, value);\n        if (newValue === null) {\n            this.remove(key);\n        } else {\n            this.put(key, newValue);\n            return newValue;\n        }\n    }\n\n    put(key: K, value: V): V {\n        let previousValue: V = null;\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        if (this.containsKey(key))\n            this._entries = this._entries\n                .map((mapEntry: IMapEntry<K, V>) => {\n                    if (mapEntry.getKey() === key)\n                        previousValue = mapEntry.setValue(value);\n                    return mapEntry;\n                });\n        else\n            this._entries.push(new MapEntry<K, V>(key, value));\n\n        return previousValue;\n    }\n\n    putAll(m: IMap<K, V>): void {\n        m.entrySet()\n            .toArray()\n            .forEach((mapEntry: IMapEntry<K, V>) => this.put(mapEntry.getKey(), mapEntry.getValue()));\n    }\n\n    putIfAbsent(key: K, value: V): V {\n\n        if (key === null || key === undefined)\n            throw new NullReferenceException('The key cannot be null nor undefined');\n\n        let v: V = this.get(key);\n\n        if (v === null)\n            v = this.put(key, value);\n\n        return v;\n    }\n\n    remove(key: K): V;\n    remove(key: K, value: V): boolean;\n    remove(key: K, value?: V): any {\n        if (value)\n            if (this.containsKey(key) && this.get(key) === value) {\n                this.remove(key);\n                return true;\n            } else {\n                return false;\n            }\n        else {\n\n            if (key === null || key === undefined)\n                throw new NullReferenceException('The key cannot be null nor undefined');\n\n            let length: number = this._entries.length;\n            this._entries = this._entries\n                .filter((mapEntry: IMapEntry<K, V>) => mapEntry.getKey() !== key);\n            return this._entries.length !== length;\n        }\n    }\n\n    replace(key: K, value: V): V;\n    replace(key: K, oldValue: V, newValue: V): boolean;\n    replace(key: K, value: V, newValue?: V): any {\n        if (newValue)\n            if (this.containsKey(key) && this.get(key) === value) {\n                this.put(key, newValue);\n                return true;\n            } else {\n                return false;\n            }\n        else {\n            if (key === null || key === undefined)\n                throw new NullReferenceException('The key cannot be null nor undefined');\n\n            if (this.containsKey(key)) {\n                return this.put(key, value);\n            } else {\n                return null;\n            }\n        }\n    }\n\n    replaceAll(f: IBiFunction<K, V, V>): void {\n\n        if (f === null || f === undefined)\n            throw new NullReferenceException('The function cannot be null nor undefined');\n\n        this.entrySet().toArray().forEach((mapEntry: IMapEntry<K, V>) => {\n            mapEntry.setValue(f.apply(mapEntry.getKey(), mapEntry.getValue()));\n        });\n    }\n\n    size(): number {\n        return this._entries.length;\n    }\n\n    values(): V[] {\n        return this._entries\n            .map((mapEntry: IMapEntry<K, V>) => mapEntry.getValue());\n    }\n}","import { DoublyLinkedList } from '../linked-list/doubly-linked-list/doubly-linked-list';\nimport { IQueue } from './queue-interface';\n\nexport class Queue<T> implements IQueue<T> {\n\n    private _items: DoublyLinkedList<T>;\n\n    constructor() {\n        this._items = new DoublyLinkedList<T>();\n    }\n\n    public length() {\n        return this._items.length();\n    }\n\n    public enqueue(item: T): void {\n        this._items.push(item);\n    }\n\n    public dequeue(): T {\n        return this._items.shift();\n    }\n\n    public peek(): T {\n        return this._items.peek();\n    }\n\n    public back(): T {\n        return this._items.back();\n    }\n\n    public empty(): boolean {\n        return this._items.empty();\n    }\n}","import { SinglyLinkedList } from '../linked-list/singly-linked-list/singly-linked-list';\nimport { IStack } from './stack-interface';\n\nexport class Stack<T> implements IStack<T> {\n\n    private _items: SinglyLinkedList<T>;\n\n    constructor() {\n        this._items = new SinglyLinkedList<T>();\n    }\n\n    public length() {\n        return this._items.length();\n    }\n\n    public stack(item: T): void {\n        this._items.unshift(item);\n    }\n\n    public unstack(): T {\n        return this._items.shift();\n    }\n\n    public peek(): T {\n        return this._items.peek();\n    }\n\n    public empty(): boolean {\n        return this._items.empty();\n    }\n}","import { Exception } from './exception';\n\nexport class ClassCastException extends Exception {\n\n    constructor(message: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `ClassCast${super.toString()}`;\n    }\n}","import { Exception } from './exception';\n\nexport class IndexOutOfBoundsException extends Exception {\n\n    constructor(message?: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `IndexOutOfBounds${super.toString()}`;\n    }\n}","import { Exception } from './exception';\n\nexport class ReadOnlyBufferException extends Exception {\n\n    constructor(message?: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `ReadOnlyBuffer${super.toString()}`;\n    }\n}","import { Exception } from './exception';\n\nexport class UnsupportedOperationException extends Exception {\n\n    constructor(message: string) {\n        super(message);\n    }\n\n    public toString() {\n        return `UnsupportedOperation${super.toString()}`;\n    }\n}","import {IBiFunction} from './bi-function-interface';\nimport {IFunction} from '../function/function-interface';\n\nexport class BiFunction<T, U, R> implements IBiFunction<T, U, R> {\n\n    // Cannot type this one as Native Function because this class redifines it\n    private _function: any;\n\n    getNativeFunction() {\n        return this._function;\n    }\n\n    constructor(f: (t: T, u: U) => R) {\n        this._function = f;\n    }\n\n    andThen<V>(after: IFunction<R, V>): IBiFunction<T, U, R> {\n        return new BiFunction<T, U, R>(\n            (t: T, u: U) => {\n                return after.getNativeFunction()(this.getNativeFunction()(t, u));\n            }\n        );\n    }\n\n    apply(t: T, u: U): R {\n        return this._function(t, u);\n    }\n\n}","import {IFunction} from './function-interface';\n\nexport class Function<T, R> implements IFunction<T, R> {\n\n    // Cannot type this one as Native Function because this class redifines it\n    private _function: any;\n\n    constructor(f: (t: T) => R) {\n        this._function = f;\n    }\n\n    getNativeFunction() {\n        return this._function;\n    }\n\n    andThen<V>(after: IFunction<R, V>): IFunction<T, V> {\n        return new Function<T, V>(\n            (t: T) => {\n                return after.getNativeFunction()(this.getNativeFunction()(t));\n            }\n        );\n    }\n\n    apply(t: T): R {\n        return this._function(t);\n    }\n\n    compose<V>(before: IFunction<V, T>): IFunction<V, R> {\n        return new Function<V, R>(\n            (t: V) => {\n                return this.getNativeFunction()(before.getNativeFunction()(t));\n            }\n        );\n    }\n\n    identity<T>(): IFunction<T, T> {\n        return new Function<T, T>((t: T) => t);\n    }\n}","import * as  IFunctionImport from './src/functions/function/function-interface';\nexport import IFunction = IFunctionImport.IFunction;\n\nimport * as FunctionImport from './src/functions/function/function';\nexport import Function = FunctionImport.Function;\n\nimport * as BiFunctionImport from './src/functions/bi-function/bi-function';\nexport import BiFunction = BiFunctionImport.BiFunction;\n\nimport * as UnsupportedOperationExceptionImport from './src/exceptions/unsupported-operation-exception';\nexport import UnsupportedOperationException = UnsupportedOperationExceptionImport.UnsupportedOperationException;\n\nimport * as ReadOnlyBufferExceptionImport from './src/exceptions/read-only-buffer-exception';\nexport import ReadOnlyBufferException = ReadOnlyBufferExceptionImport.ReadOnlyBufferException;\n\nimport * as NullReferenceExceptionImport from './src/exceptions/null-reference-exception';\nexport import NullReferenceException = NullReferenceExceptionImport.NullReferenceException;\n\nimport * as InvalidMarkExceptionImport from './src/exceptions/invalid-mark-exception';\nexport import InvalidMarkException = InvalidMarkExceptionImport.InvalidMarkException;\n\nimport * as IndexOutOfBoundsExceptionImport from './src/exceptions/index-out-of-bounds-exception';\nexport import IndexOutOfBoundsException = IndexOutOfBoundsExceptionImport.IndexOutOfBoundsException;\n\nimport * as IllegalArgumentExceptionImport from './src/exceptions/illegal-argument-exception';\nexport import IllegalArgumentException = IllegalArgumentExceptionImport.IllegalArgumentException;\n\nimport * as ExceptionImport from './src/exceptions/exception';\nexport import Exception = ExceptionImport.Exception;\n\nimport * as ClassCastExceptionImport from './src/exceptions/class-cast-exception';\nexport import ClassCastException = ClassCastExceptionImport.ClassCastException;\n\nimport *  as IStackImport from './src/collections/stack/stack-interface';\nexport import IStack = IStackImport.IStack;\n\nimport * as StackImport from './src/collections/stack/stack';\nexport import Stack = StackImport.Stack;\n\nimport * as ISetInterfaceImport from './src/collections/set/set-interface';\nexport import ISetInterface = ISetInterfaceImport.ISetInterface;\n\nimport * as IQueueImport from './src/collections/queue/queue-interface';\nexport import IQueue = IQueueImport.IQueue;\n\nimport * as QueueImport from './src/collections/queue/queue';\nexport import Queue = QueueImport.Queue;\n\nimport * as IMapImport from './src/collections/map/map-interface';\nexport import IMap = IMapImport.IMap;\n\nimport * as MapImport from './src/collections/map/map';\nexport import Map = MapImport.Map;\n\nimport * as IMapEntryImport from './src/collections/map/utils/map-entry/map-entry-interface';\nexport import IMapEntry = IMapEntryImport.IMapEntry;\n\nimport * as MapEntryImport from './src/collections/map/utils/map-entry/map-entry';\nexport import MapEntry = MapEntryImport.MapEntry;\n\nimport * as ILinkedListImport from './src/collections/linked-list/linked-list-interface';\nexport import ILinkedList = ILinkedListImport.ILinkedList;\n\nimport * as INodeImport from './src/collections/linked-list/utils/node/node-interface';\nexport import INode = INodeImport.INode;\n\nimport * as NodeImport from './src/collections/linked-list/utils/node/node';\nexport import Node = NodeImport.Node;\n\nimport * as SinglyLinkedListImport from './src/collections/linked-list/singly-linked-list/singly-linked-list';\nexport import SinglyLinkedList = SinglyLinkedListImport.SinglyLinkedList;\n\nimport * as DoublyLinkedListImport from './src/collections/linked-list/doubly-linked-list/doubly-linked-list';\nexport import DoublyLinkedList = DoublyLinkedListImport.DoublyLinkedList;\n\nimport * as IBufferImport from './src/collections/buffer/buffer-interface';\nexport import IBuffer = IBufferImport.IBuffer;\n\nimport * as BufferImport from './src/collections/buffer/buffer';\nexport import Buffer = BufferImport.Buffer;\n\nimport * as GenericRingBufferImport from './src/collections/buffer/generic-ring-buffer/generic-ring-buffer';\nexport import GenericRingBuffer = GenericRingBufferImport.GenericRingBuffer;\n\nimport * as GenericBufferImport from './src/collections/buffer/generic-buffer/generic-buffer';\nexport import GenericBuffer = GenericBufferImport.GenericBuffer;"],"sourceRoot":""}